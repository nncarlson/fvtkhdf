!!
!! VTKHDF_MB_FILE_TYPE
!!
!! This module defines a derived type for exporting mesh-based solution data
!! to a VTKHDF format file that can be read by the ParaView visualizaton tool.
!! The format uses HDF5 for on-disk storage.
!!
!! Neil Carlson <neil.n.carlson@gmail.com>
!! January 2026
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! NOTES
!!
!! The up-to-date specification for VTKHDF is at
!! https://docs.vtk.org/en/latest/vtk_file_formats/vtkhdf_mb_file_format/index.html
!!
!! This module was written for version 2.5 of the format.
!!
!! This module uses the "MultiBlockDataSet" type of format. It supports static
!! and time dependent data (point and cell), but assumes a single static mesh.
!! The "Assembly" dataset hierarchy is limited to a flat collection
!! of UnstructuredGrid blocks.
!!

#include "f90_assert.fpp"

module vtkhdf_mb_file_type

  use,intrinsic :: iso_fortran_env
  use vtkhdf_h5_c_binding
  use vtkhdf_h5
  use vtkhdf_ug_type
  use vtkhdf_ctx_type
  implicit none
  private

#:set num_specs = [ {"suffix":"int32",  "decl":"integer(int32)"}, &
                  & {"suffix":"int64",  "decl":"integer(int64)"}, &
                  & {"suffix":"real32", "decl":"real(real32)"}, &
                  & {"suffix":"real64", "decl":"real(real64)"} ]
#:set locations = ["cell", "point"]
  type, public :: vtkhdf_mb_file
    private
    type(vtkhdf_ctx) :: ctx
    integer(hid_t) :: file_id=H5I_INVALID_HID, vtk_id=H5I_INVALID_HID, ass_id=H5I_INVALID_HID
    integer :: next_bid = 0
    type(pdc_block), pointer :: blocks => null()
  contains
    procedure :: create
    procedure :: close
    procedure :: add_block
    procedure :: write_block_mesh
    procedure :: write_time_step
#:for s in num_specs
#:for loc in locations
    generic :: write_${loc}$_data => write_${loc}$_data_${s["suffix"]}$
    procedure, private :: write_${loc}$_data_${s["suffix"]}$
    generic :: register_temporal_${loc}$_data => register_temporal_${loc}$_data_${s["suffix"]}$
    procedure, private :: register_temporal_${loc}$_data_${s["suffix"]}$
    generic :: write_temporal_${loc}$_data => write_temporal_${loc}$_data_${s["suffix"]}$
    procedure, private :: write_temporal_${loc}$_data_${s["suffix"]}$
#:endfor
#:endfor
    procedure, private :: get_block_ptr
    final :: vtkhdf_mb_file_delete
  end type

  type :: pdc_block
    character(:), allocatable :: name
    type(vtkhdf_ug) :: b
    type(pdc_block), pointer :: next => null()
  contains
    final :: pdc_block_delete
  end type

  !! TODO: get a more exhaustive list, separate module
  integer(int8), parameter, public :: VTK_TETRA = 10
  integer(int8), parameter, public :: VTK_HEXAHEDRON = 12
  integer(int8), parameter, public :: VTK_WEDGE = 13
  integer(int8), parameter, public :: VTK_PYRAMID = 14

  integer, parameter :: vtkhdf_version(*) = [2,5]

contains

  !! Finalizer for vtkhdf_mb_file objects. We free heap memory we own but avoid
  !! doing things that may require syncronization with other ranks (MPI/PHDF5)
  !! because where implicit finalization occurs it is not guaranteed to be
  !! collective or ordered with respect to other ranks. This can leak HDF5
  !! IDs and the MPI communicator, but that is unavoidable. Users should
  !! always use CLOSE to do a proper collective cleanup and close of the file.

  subroutine vtkhdf_mb_file_delete(this)
    use mpi, only: MPI_COMM_NULL
    type(vtkhdf_mb_file), intent(inout) :: this
    if (associated(this%blocks)) deallocate(this%blocks)
    this%ass_id  = H5I_INVALID_HID
    this%vtk_id  = H5I_INVALID_HID
    this%file_id = H5I_INVALID_HID
    this%ctx%comm = MPI_COMM_NULL
    this%next_bid = 0
  end subroutine

  recursive subroutine pdc_block_delete(this)
    type(pdc_block), intent(inout) :: this
    if (associated(this%next)) deallocate(this%next)
  end subroutine

  !! Cleanly closes H5 identifiers and the file, and default initializes.
  subroutine close(this)
    use mpi, only: MPI_COMM_NULL, MPI_Comm_free
    class(vtkhdf_mb_file), intent(inout) :: this
    integer :: ierr
    type(pdc_block), pointer :: p
    p => this%blocks
    do while (associated(p))
      call p%b%close
      p => p%next
    end do
    if (H5Iis_valid(this%ass_id) > 0) ierr = H5Gclose(this%ass_id)
    if (H5Iis_valid(this%vtk_id) > 0) ierr = H5Gclose(this%vtk_id)
    if (H5Iis_valid(this%file_id) > 0) ierr = H5Fclose(this%file_id)
    if (this%ctx%comm /= MPI_COMM_NULL) call MPI_Comm_free(this%ctx%comm, ierr)
    call finalize(this) ! free local memory
  contains
    subroutine finalize(this)
      class(vtkhdf_mb_file), intent(out) :: this
    end subroutine
  end subroutine

  subroutine create(this, filename, comm, stat, errmsg)

    use,intrinsic :: iso_c_binding, only: c_bool

    class(vtkhdf_mb_file), intent(out) :: this
    character(*), intent(in) :: filename
    integer, intent(in) :: comm
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg

    integer(hid_t) :: fapl, gcpl
    integer(c_int) :: flag
    integer :: ierr

    call this%ctx%init(comm)

    call init_hdf5

    !! Open the file (read/write), overwrite any existing file
    fapl = H5Pcreate(H5P_FILE_ACCESS)
    stat = H5Pset_fapl_mpio(fapl, this%ctx%comm)
    stat = H5Pset_all_coll_metadata_ops(fapl, is_collective=.true._c_bool)
    stat = H5Pset_coll_metadata_write(fapl, is_collective=.true._c_bool)
    this%file_id = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, fapl)
    ierr = H5Pclose(fapl)
    if (this%ctx%global_any(this%file_id < 0)) then
      stat = 1
      errmsg = 'failed to open file'
      return
    end if

    !! Group creation properties for PDC datasets (no harm to others)
    !! Applies to VTKHDF and Assembly groups
    flag = ior(H5P_CRT_ORDER_TRACKED, H5P_CRT_ORDER_INDEXED)
    gcpl = H5Pcreate(H5P_GROUP_CREATE)
    stat = H5Pset_link_creation_order(gcpl, flag)
    INSIST(stat == 0)

    !! Create the root VTKHDF group and write its attributes
    this%vtk_id = H5Gcreate(this%file_id, 'VTKHDF', gcpl_id=gcpl)
    if (this%ctx%global_any(this%vtk_id < 0)) then
      stat = 1
      errmsg = 'failed to create "VTKHDF" group'
      return
    end if

    call h5_write_attr(this%ctx, this%vtk_id, 'Version', vtkhdf_version, stat, errmsg)
    if (stat /= 0) return

    !NB: We stick with the older MB type due to an issue with the modern PDC
    !type; see https://gitlab.kitware.com/vtk/vtk/-/issues/19902
    !call h5_write_attr(this%ctx, this%vtk_id, 'Type', 'PartitionedDataSetCollection', stat, errmsg)
    call h5_write_attr(this%ctx, this%vtk_id, 'Type', 'MultiBlockDataSet', stat, errmsg)
    if (stat /= 0) return

    !! Create the Assembly group
    this%ass_id = H5Gcreate(this%vtk_id, 'Assembly', gcpl_id=gcpl)
    ierr = H5Pclose(gcpl)
    if (this%ctx%global_any(this%ass_id < 0)) then
      stat = 1
      errmsg = 'failed to create "Assembly" group'
      return
    end if

  end subroutine create


  subroutine add_block(this, name, stat, errmsg, temporal)

    class(vtkhdf_mb_file), intent(inout) :: this
    character(*), intent(in) :: name
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg
    logical, intent(in), optional :: temporal

    integer :: n, ierr
    type(pdc_block), pointer :: b, new

    !! Ensure the specified NAME is valid
    if (name == '') then
      stat = 1
      errmsg = 'invalid empty block name'
      return
    end if

    n = scan(name, './')
    if (n /= 0) then
      stat = 1
      errmsg = 'invalid character "' // name(n:n) // '" in block name'
      return
    end if

    if (name == 'Assembly') then
      stat = 1
      errmsg = 'invalid block name "Assembly"'
      return
    end if

    b => this%blocks
    do while (associated(b))
      if (b%name == name) then
        stat = 1
        errmsg = 'block "' // name // '" already defined'
        return
      end if
      b => b%next
    end do

    !! Create the UG block group and its HDF5 hierarchy
    allocate(new)
    new%name = name
    new%next => this%blocks
    this%blocks => new

    call new%b%init(this%vtk_id, name, this%ctx, stat, errmsg, temporal)
    if (stat /= 0) then
      errmsg = 'error adding UnstructuredGrid block "' // name // '": ' // errmsg
      return
    end if

    !NB: Unused for MultiBlockDataSet, but required for PartitionedDataSetCollection.
    call h5_write_attr(this%ctx, new%b%root_id, 'Index', this%next_bid, stat, errmsg)
    if (stat /= 0) then
      errmsg = 'error adding UnstructuredGrid block "' // name // '": ' // errmsg
      return
    end if
    this%next_bid = this%next_bid + 1

    !! Create a softlink in Assembly group to the block group.
    ierr = H5Lcreate_soft('/VTKHDF/'//name, this%ass_id, name)
    if (this%ctx%global_any(ierr < 0)) then
      stat = 1
      errmsg = 'unable to create "Assembly" group link to block "' // name // '"'
      return
    end if

    stat = 0

  end subroutine add_block

  !! Write the UnstructuredGrid data for the specified block. The unstructured
  !! mesh is described in the conventional manner by the X, CNODE, and XCNODE
  !! arrays. The additional array TYPES provides an unambiguous specification
  !! of the cell types that one might otherwise infer from the XCNODE array.
  !! This procedure must be called for each of the blocks before any of the
  !! following procedures.

  subroutine write_block_mesh(this, block_name, x, cnode, xcnode, types, stat, errmsg)

    class(vtkhdf_mb_file), intent(inout) :: this
    character(*), intent(in) :: block_name
    real(real64), intent(in) :: x(:,:)
    integer, intent(in) :: cnode(:), xcnode(:)
    integer(int8), intent(in) :: types(:)
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg

    type(vtkhdf_ug), pointer :: bptr

    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%write_mesh(x, cnode, xcnode, types, stat, errmsg)

  end subroutine write_block_mesh

  !! Writes the cell-based data ARRAY to a new named cell dataset for the
  !! specified mesh block. Scalar, vector, and tensor cell-based data are
  !! supported. In the case of a temporal block supporting time-dependent
  !! datasets, this dataset is static and not associated with any time step.
#:for s in num_specs

  subroutine write_cell_data_${s["suffix"]}$(this, block_name, name, array, stat, errmsg)
    class(vtkhdf_mb_file), intent(in) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: array(..)
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%write_cell_data_${s["suffix"]}$(name, array, stat, errmsg)
  end subroutine
#:endfor

  !! Writes the point-based data ARRAY to a new named cell dataset for the
  !! specified mesh block. Scalar, vector, and tensor cell-based data are
  !! supported. In the case of a temporal block supporting time-dependent
  !! datasets, this dataset is static and not associated with any time step.
#:for s in num_specs

  subroutine write_point_data_${s["suffix"]}$(this, block_name, name, array, stat, errmsg)
    class(vtkhdf_mb_file), intent(in) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: array(..)
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%write_point_data_${s["suffix"]}$(name, array, stat, errmsg)
  end subroutine
#:endfor

  !! Register the specified NAME as a time-dependent cell dataset for the
  !! specified mesh block. This writes no data, but only configures some
  !! necessary internal metadata. The MOLD array argument shall have the same
  !! type, kind, and rank as the actual dataset, and the same extent in all
  !! but the last dimension, whose extent is ignored, but the array values
  !! themselves are not accessed. Scalar, vector, and tensor-valued mesh
  !! data are supported (rank-1, 2, and 3 MOLD).
#:for s in num_specs

  subroutine register_temporal_cell_data_${s["suffix"]}$(this, block_name, name, mold, stat, errmsg)
    class(vtkhdf_mb_file), intent(inout) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: mold(..)
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%register_temporal_cell_data_${s["suffix"]}$(name, mold, stat, errmsg)
  end subroutine
#:endfor

  !! Register the specified NAME as a time-dependent point dataset for the
  !! specified mesh block. This writes no data, but only configures some
  !! necessary internal metadata. The MOLD array argument shall have the same
  !! type, kind, and rank as the actual dataset, and the same extent in all
  !! but the last dimension, whose extent is ignored, but the array values
  !! themselves are not accessed. Scalar, vector, and tensor-valued mesh
  !! data are supported (rank-1, 2, and 3 MOLD).
#:for s in num_specs

  subroutine register_temporal_point_data_${s["suffix"]}$(this, block_name, name, mold, stat, errmsg)
    class(vtkhdf_mb_file), intent(inout) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: mold(..)
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%register_temporal_point_data_${s["suffix"]}$(name, mold, stat, errmsg)
  end subroutine
#:endfor

  !! Mark the start of a new time step with time value TIME. Subsequent output
  !! of time-dependent datasets will be associated with this time step.

  subroutine write_time_step(this, time)
    class(vtkhdf_mb_file), intent(inout) :: this
    real(real64), intent(in) :: time
    type(pdc_block), pointer :: b
    b => this%blocks
    do while (associated(b))
      if (b%b%nsteps >= 0) call b%b%write_time_step(time)
      b => b%next
    end do
  end subroutine

  !! Write the cell-based data ARRAY to the named time-dependent cell dataset
  !! for the specified mesh block. The data is associated with the current
  !! time step.
#:for s in num_specs

  subroutine write_temporal_cell_data_${s["suffix"]}$(this, block_name, name, array, stat, errmsg)
    class(vtkhdf_mb_file), intent(in) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: array(..)
    integer, intent(out) :: stat
    character(:), allocatable :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%write_temporal_cell_data_${s["suffix"]}$(name, array, stat, errmsg)
  end subroutine
#:endfor

  !! Write the point-based data ARRAY to the named time-dependent cell dataset
  !! for the specified mesh block. The data is associated with the current
  !! time step.
#:for s in num_specs

  subroutine write_temporal_point_data_${s["suffix"]}$(this, block_name, name, array, stat, errmsg)
    class(vtkhdf_mb_file), intent(in) :: this
    character(*), intent(in) :: block_name, name
    ${s["decl"]}$, intent(in) :: array(..)
    integer, intent(out) :: stat
    character(:), allocatable :: errmsg
    type(vtkhdf_ug), pointer :: bptr
    call this%get_block_ptr(block_name, bptr, stat, errmsg)
    if (stat /= 0) return
    call bptr%write_temporal_point_data_${s["suffix"]}$(name, array, stat, errmsg)
  end subroutine
#:endfor

  !! This auxiliary procedure returns a pointer to the named block, or a null
  !! pointer if the block does not exist. If successful (block exists) STAT
  !! returns 0; otherwise it returns a non-zero value and ERRMSG returns an
  !! informative error message.

  subroutine get_block_ptr(this, name, bptr, stat, errmsg)

    class(vtkhdf_mb_file), intent(in) :: this
    character(*), intent(in) :: name
    type(vtkhdf_ug), pointer, intent(out) :: bptr
    integer, intent(out) :: stat
    character(:), allocatable, intent(out) :: errmsg

    type(pdc_block), pointer :: b

    b => this%blocks
    do while (associated(b))
      if (b%name == name) exit
      b => b%next
    end do

    stat = merge(0, -1, associated(b))
    if (stat == 0) then
      bptr => b%b
    else
      bptr => null()
      errmsg = 'no such block "' // name // '"'
    end if

  end subroutine get_block_ptr

end module vtkhdf_mb_file_type
